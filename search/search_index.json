{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DAA Assignment 2 In this project we implement two algorithms for finding Densest subgraph discovery in an undirected graph in C++. The algorithms are: 1. The algorithm 1 from page 1721 from the paper titled Efficient Algorithms for Densest Subgraph Discovery; by Yixiang Fang ,Kaiqiang Yu ,Reynold Cheng ,Laks V.S. Lakshmanan ,Xuemin Lin (Link: [https://www.vldb.org/pvldb/vol12/p1719-fang.pdf]). 2. The algorithm 4 from page 1725 from the paper titled Efficient Algorithms for Densest Subgraph Discovery; by Yixiang Fang ,Kaiqiang Yu ,Reynold Cheng ,Laks V.S. Lakshmanan ,Xuemin Lin (Link: [https://www.vldb.org/pvldb/vol12/p1719-fang.pdf]). We then executed these algorithms on four graph datasets: 1. As733 2. Yeast 3. Ca-HepTh 4. NetScience We treated these datasets as undirected graphs and applied these algorithms. The input is taken from a text file with some optional text, including number of vertices, followed by edges, and the rest of the lines denoting a pair of vertices with an edge between them. We store the graphs in adjacency list format. The results are shown in the algorithm-wise markdowns, and the report. Webpage Link: Contributions The various tasks and their contributions are given below: 1. Algorithm 1 implementation: Amritansh 2. Algorithm 2 Implementation: Amritansh 3. Report: Saarthek Raj , Abdul Rahman Yakoob Run Locally 1.Download the zip file with codes from the submission. 2. Download the dataset zip folder from the google drive link. (Link: https://drive.google.com/drive/folders/1GZz6tX6ZHZ5rjc-O70JKMAp1rdhZ5Ech). 3. Extract the dataset .txt files from the zip folder and put them in the same folder where all the codes are. 4. Go to the project directory. 5. Compile the file and run it. For Unix/Mac: g++ <file-name>.cpp -o <file-name>.out ./<file-name>.out <dataset>.txt <h> For Windows: g++ <file-name>.cpp -o <file-name>.exe ./<file-name>.exe <dataset>.txt <h> <file-name> can be algo1 or algo4, and <h> is number of vertices in the clique. Example for Algorithm 1 with Yeast for edge-based density we input: g++ algo1.cpp -o algo1.exe ./algo1.exe yeast.txt 2","title":"Home"},{"location":"#daa-assignment-2","text":"In this project we implement two algorithms for finding Densest subgraph discovery in an undirected graph in C++. The algorithms are: 1. The algorithm 1 from page 1721 from the paper titled Efficient Algorithms for Densest Subgraph Discovery; by Yixiang Fang ,Kaiqiang Yu ,Reynold Cheng ,Laks V.S. Lakshmanan ,Xuemin Lin (Link: [https://www.vldb.org/pvldb/vol12/p1719-fang.pdf]). 2. The algorithm 4 from page 1725 from the paper titled Efficient Algorithms for Densest Subgraph Discovery; by Yixiang Fang ,Kaiqiang Yu ,Reynold Cheng ,Laks V.S. Lakshmanan ,Xuemin Lin (Link: [https://www.vldb.org/pvldb/vol12/p1719-fang.pdf]). We then executed these algorithms on four graph datasets: 1. As733 2. Yeast 3. Ca-HepTh 4. NetScience We treated these datasets as undirected graphs and applied these algorithms. The input is taken from a text file with some optional text, including number of vertices, followed by edges, and the rest of the lines denoting a pair of vertices with an edge between them. We store the graphs in adjacency list format. The results are shown in the algorithm-wise markdowns, and the report. Webpage Link:","title":"DAA Assignment 2"},{"location":"#contributions","text":"The various tasks and their contributions are given below: 1. Algorithm 1 implementation: Amritansh 2. Algorithm 2 Implementation: Amritansh 3. Report: Saarthek Raj , Abdul Rahman Yakoob","title":"Contributions"},{"location":"#run-locally","text":"1.Download the zip file with codes from the submission. 2. Download the dataset zip folder from the google drive link. (Link: https://drive.google.com/drive/folders/1GZz6tX6ZHZ5rjc-O70JKMAp1rdhZ5Ech). 3. Extract the dataset .txt files from the zip folder and put them in the same folder where all the codes are. 4. Go to the project directory. 5. Compile the file and run it. For Unix/Mac: g++ <file-name>.cpp -o <file-name>.out ./<file-name>.out <dataset>.txt <h> For Windows: g++ <file-name>.cpp -o <file-name>.exe ./<file-name>.exe <dataset>.txt <h> <file-name> can be algo1 or algo4, and <h> is number of vertices in the clique. Example for Algorithm 1 with Yeast for edge-based density we input: g++ algo1.cpp -o algo1.exe ./algo1.exe yeast.txt 2","title":"Run Locally"},{"location":"Algorithms/","text":"Algorithms Algorithm 1 Algorithm 1 (Exact) is the baseline exact algorithm for solving the Clique Densest Subgraph (CDS) problem, which aims to find a subgraph with the highest h-clique-density. It uses a binary search approach combined with flow network techniques. Here's how the Exact algorithm works: It initializes lower and upper bounds for the density parameter \u03b1. The lower bound is set to 0, and the upper bound is calculated as the maximum clique-degree of any vertex divided by the clique size. The algorithm creates a flow network F(V_F, E_F) with: A source node s and a sink node t. Nodes representing all vertices in the original graph. Directed edges from s to each vertex with capacity equal to that vertex's clique-degree. Directed edges between vertices that form (h-1)-cliques, with capacity set to infinity. Directed edges from each vertex to t with capacity \u03b1. It performs binary search on the parameter \u03b1: In each iteration, it builds the flow network with the current \u03b1 value. Computes the minimum s-t cut (S,T) using Goldberg's algorithm. Updates \u03b1 based on the result: If S={s}, then \u03b1 is too large, so the upper bound is updated. Otherwise, \u03b1 is too small, so the lower bound is updated. The algorithm terminates when the gap between upper and lower bounds becomes sufficiently small, and returns the subgraph D induced by the set S{s}. The paper notes that while Exact provides optimal solutions, it has limitations: Initial bounds on \u03b1 may not be tight. The flow network can become large for graphs with many clique instances. The algorithm rebuilds the flow network on the entire graph in each iteration. These limitations are addressed in Algorithm 4 (CoreExact), which improves efficiency through the core-based approach. Algorithm 4 Algorithm 4 (CoreExact) is an optimized approach for solving the Clique Densest Subgraph (CDS) problem, which aims to find a subgraph with the highest h-clique-density. The algorithm improves upon the basic Exact algorithm by leveraging k-clique-cores and several optimization techniques to reduce computational cost. Here's how CoreExact works: It begins by performing core decomposition using Algorithm 3, which computes the clique-core number of each vertex. It then locates the (k'', \u03a8)-core using pruning criteria, where k'' represents the core with the highest h-clique-density among residual graphs. The algorithm initializes a set C to contain all connected components of the (k'', \u03a8)-core that might contain the CDS. For each connected component in C, it: Builds a flow network if the component's core number is high enough. Performs binary search to find the optimal \u03b1 value. Uses minimum s-cut calculations to identify dense subgraphs. Updates bounds as the search progresses The algorithm employs three key optimizations: Tighter bounds on \u03b1 using (k,\u03a8)-cores. Pruning techniques to identify which cores might contain the CDS. A strategy to make the flow network gradually smaller during iterations. Finally, it returns the subgraph D with the highest h-clique-density. The main advantage of CoreExact over the basic Exact algorithm is efficiency - it significantly reduces computational cost by: Working with smaller subgraphs (cores) rather than the entire graph. Using tighter bounds for binary search. Progressively reducing the flow network size.","title":"Algorithms"},{"location":"Algorithms/#algorithms","text":"","title":"Algorithms"},{"location":"Algorithms/#algorithm-1","text":"Algorithm 1 (Exact) is the baseline exact algorithm for solving the Clique Densest Subgraph (CDS) problem, which aims to find a subgraph with the highest h-clique-density. It uses a binary search approach combined with flow network techniques. Here's how the Exact algorithm works: It initializes lower and upper bounds for the density parameter \u03b1. The lower bound is set to 0, and the upper bound is calculated as the maximum clique-degree of any vertex divided by the clique size. The algorithm creates a flow network F(V_F, E_F) with: A source node s and a sink node t. Nodes representing all vertices in the original graph. Directed edges from s to each vertex with capacity equal to that vertex's clique-degree. Directed edges between vertices that form (h-1)-cliques, with capacity set to infinity. Directed edges from each vertex to t with capacity \u03b1. It performs binary search on the parameter \u03b1: In each iteration, it builds the flow network with the current \u03b1 value. Computes the minimum s-t cut (S,T) using Goldberg's algorithm. Updates \u03b1 based on the result: If S={s}, then \u03b1 is too large, so the upper bound is updated. Otherwise, \u03b1 is too small, so the lower bound is updated. The algorithm terminates when the gap between upper and lower bounds becomes sufficiently small, and returns the subgraph D induced by the set S{s}. The paper notes that while Exact provides optimal solutions, it has limitations: Initial bounds on \u03b1 may not be tight. The flow network can become large for graphs with many clique instances. The algorithm rebuilds the flow network on the entire graph in each iteration. These limitations are addressed in Algorithm 4 (CoreExact), which improves efficiency through the core-based approach.","title":"Algorithm 1"},{"location":"Algorithms/#algorithm-4","text":"Algorithm 4 (CoreExact) is an optimized approach for solving the Clique Densest Subgraph (CDS) problem, which aims to find a subgraph with the highest h-clique-density. The algorithm improves upon the basic Exact algorithm by leveraging k-clique-cores and several optimization techniques to reduce computational cost. Here's how CoreExact works: It begins by performing core decomposition using Algorithm 3, which computes the clique-core number of each vertex. It then locates the (k'', \u03a8)-core using pruning criteria, where k'' represents the core with the highest h-clique-density among residual graphs. The algorithm initializes a set C to contain all connected components of the (k'', \u03a8)-core that might contain the CDS. For each connected component in C, it: Builds a flow network if the component's core number is high enough. Performs binary search to find the optimal \u03b1 value. Uses minimum s-cut calculations to identify dense subgraphs. Updates bounds as the search progresses The algorithm employs three key optimizations: Tighter bounds on \u03b1 using (k,\u03a8)-cores. Pruning techniques to identify which cores might contain the CDS. A strategy to make the flow network gradually smaller during iterations. Finally, it returns the subgraph D with the highest h-clique-density. The main advantage of CoreExact over the basic Exact algorithm is efficiency - it significantly reduces computational cost by: Working with smaller subgraphs (cores) rather than the entire graph. Using tighter bounds for binary search. Progressively reducing the flow network size.","title":"Algorithm 4"},{"location":"RESULTS/","text":"Experimental Results The implementations were tested on several datasets. We ran the implementations of the three algorithms on four datasets. The code was executed on a Macbook Air 1, with 8 GB RAM; execution time may differ for different devices. The datasets, with their names, number of edges, and vertices, are as follows: Dataset Vertices Edges As733 6474 13895 Netscience 1461 2742 Yeast 1458 1948 Ca-HepTh 9877 51971 Both the algorithms returned the same results for densities of densest subgraph, number of nodes, and number of h-cliques. The results are as follows: Densities of k-clique densest subgraph Result As733 NetScience Yeast Ca-HepTh 2-Clique 8.875 9.5 2.71429 15.5 3-Clique 35.9091 57 3.71429 155 4-Clique 85.125 242.25 2.71429 1123.75 5-Clique 126.767 775.2 1 6293 Number of vertices in the densest subgraph Result As733 NetScience Yeast Ca-HepTh 2-Clique 40 20 7 9877 3-Clique 33 20 7 9877 4-Clique 32 20 7 9877 5-Clique 30 20 7 9877 Number of h-cliques in the densest subgraph Result As733 NetScience Yeast Ca-HepTh 2-Clique 355 20 7 496 3-Clique 1185 20 7 4960 4-Clique 2724 20 7 35960 5-Clique 3803 20 7 201376 Execution Times in milliseconds Clique size Algorithm As733 NetScience Yeast Ca-HepTh 2-Clique Exact 288229 ms (4.5 min) 11523 ms (0.19 min) 9087 ms (0.16 min) 603314 ms (~10 min) CoreExact 261796 ms (4.3 min) 1516 ms (0.025 min) 9158 ms (0.16 min) 576454 ms (9.6 min) 3-Clique Exact 633709 ms (10.5 min) 23619 ms (0.39 min) 12414 ms (0.21 min) 1853753 ms (~30.8 min) CoreExact 571231 ms (9.5 min) 3060 ms (0.051 min) 12791 ms (0.22 min) 1820999 ms (~30.3 min) 4-Clique Exact 367144 ms (6.1 min) 36212 ms (0.60 min) 1992 ms (0.033 min) 2302033 ms (~38.37 min) CoreExact 343926 ms (5.7 min) 5058 ms (0.084 min) 708 ms (0.012 min) 2269619 ms (~37.82 min) 5-Clique Exact 354023 ms (5.9 min) 74719 ms (1.25 min) 941 ms (0.016 min) 6210599 ms (~103.51 min) CoreExact 318915 ms (5.3 min) 5712 ms (0.096 min) 1025 ms (0.0171 min) 6171616 ms (~102.86 min) As we can see from the execution times, the time taken increases with an increase in the number of vertices and edges in the graph. The smallest dataset (Yeast) took less than a fourth of a minute for all the values of h and both algorithms. In contrast, the largest dataset (Ca-HepTh) took more than 100 minutes for 5-Clique enumeration. For most cases, CoreExact is faster than Exact. The possible reason for exceptions is that clique enumeration took more time than the time gained by pruning the search space to find densest subgraphs.","title":"Results"},{"location":"RESULTS/#experimental-results","text":"The implementations were tested on several datasets. We ran the implementations of the three algorithms on four datasets. The code was executed on a Macbook Air 1, with 8 GB RAM; execution time may differ for different devices. The datasets, with their names, number of edges, and vertices, are as follows: Dataset Vertices Edges As733 6474 13895 Netscience 1461 2742 Yeast 1458 1948 Ca-HepTh 9877 51971 Both the algorithms returned the same results for densities of densest subgraph, number of nodes, and number of h-cliques. The results are as follows:","title":"Experimental Results"},{"location":"RESULTS/#densities-of-k-clique-densest-subgraph","text":"Result As733 NetScience Yeast Ca-HepTh 2-Clique 8.875 9.5 2.71429 15.5 3-Clique 35.9091 57 3.71429 155 4-Clique 85.125 242.25 2.71429 1123.75 5-Clique 126.767 775.2 1 6293","title":"Densities of k-clique densest subgraph"},{"location":"RESULTS/#number-of-vertices-in-the-densest-subgraph","text":"Result As733 NetScience Yeast Ca-HepTh 2-Clique 40 20 7 9877 3-Clique 33 20 7 9877 4-Clique 32 20 7 9877 5-Clique 30 20 7 9877","title":"Number of vertices in the densest subgraph"},{"location":"RESULTS/#number-of-h-cliques-in-the-densest-subgraph","text":"Result As733 NetScience Yeast Ca-HepTh 2-Clique 355 20 7 496 3-Clique 1185 20 7 4960 4-Clique 2724 20 7 35960 5-Clique 3803 20 7 201376","title":"Number of h-cliques in the densest subgraph"},{"location":"RESULTS/#execution-times-in-milliseconds","text":"Clique size Algorithm As733 NetScience Yeast Ca-HepTh 2-Clique Exact 288229 ms (4.5 min) 11523 ms (0.19 min) 9087 ms (0.16 min) 603314 ms (~10 min) CoreExact 261796 ms (4.3 min) 1516 ms (0.025 min) 9158 ms (0.16 min) 576454 ms (9.6 min) 3-Clique Exact 633709 ms (10.5 min) 23619 ms (0.39 min) 12414 ms (0.21 min) 1853753 ms (~30.8 min) CoreExact 571231 ms (9.5 min) 3060 ms (0.051 min) 12791 ms (0.22 min) 1820999 ms (~30.3 min) 4-Clique Exact 367144 ms (6.1 min) 36212 ms (0.60 min) 1992 ms (0.033 min) 2302033 ms (~38.37 min) CoreExact 343926 ms (5.7 min) 5058 ms (0.084 min) 708 ms (0.012 min) 2269619 ms (~37.82 min) 5-Clique Exact 354023 ms (5.9 min) 74719 ms (1.25 min) 941 ms (0.016 min) 6210599 ms (~103.51 min) CoreExact 318915 ms (5.3 min) 5712 ms (0.096 min) 1025 ms (0.0171 min) 6171616 ms (~102.86 min) As we can see from the execution times, the time taken increases with an increase in the number of vertices and edges in the graph. The smallest dataset (Yeast) took less than a fourth of a minute for all the values of h and both algorithms. In contrast, the largest dataset (Ca-HepTh) took more than 100 minutes for 5-Clique enumeration. For most cases, CoreExact is faster than Exact. The possible reason for exceptions is that clique enumeration took more time than the time gained by pruning the search space to find densest subgraphs.","title":"Execution Times in milliseconds"}]}